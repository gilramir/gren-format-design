module DocConstructors exposing (..)

import PrettyExpressive as P


{- Useful for traditionally-formatted "exposing" statements
for "module" and "import".
-}
listOnePerLine : Int -> Array String -> P.Doc cost
listOnePerLine indent items =
    when Array.popFirst items is
        Nothing ->
            P.concat P.lparen P.rparen

        Just { first, rest } ->
            let
                firstDoc = P.text ("( " ++ first)
                restDocs = Array.map (\s -> P.text (", " ++ s)) rest
                itemDocs = [ firstDoc ] ++ restDocs ++ [ P.rparen ]
            in
            P.nest indent
                (P.concat P.hardNl
                    (P.vcat itemDocs)
                )


{-
Given a list of strings, produce ( s1, s2, s3 )
that tries to fit on one line, but if it doesn't, will
render one per line.

The three outputs this produces:
```
-- flat (everything fits):
( Command(..), MakeFlags, DiffArgs(..), parser )

-- broken (doesn't fit):
( Command(..)
, MakeFlags
, DiffArgs(..)
, parser
)

-- single element:
(Command(..))

-- empty:
()

The caller needs to group this with the desired nesting level, like this:

P.group
    (P.nest 4
        (P.concat P.nl
            (parenList [ "Command(..)", "MakeFlags", "DiffArgs(..)", "parser" ])
        )
    )
-}
parenList : Array String -> P.Doc cost
parenList items =
    when Array.popFirst items is
        Nothing ->
            -- Empty list: "()"
            P.concat P.lparen P.rparen

        Just { first, rest } ->
            if Array.isEmpty rest then
                -- Single element: "(foo)" — no separators, no newlines
                P.concat P.lparen (P.concat (P.text first) P.rparen)

            else
                -- Multiple elements.
                -- Build doc nodes: "( item1", ", item2", ..., ", itemN"
                let
                    firstDoc = P.text ("( " ++ first)
                    restDocs = Array.map (\s -> P.text (", " ++ s)) rest
                    allItemDocs = [ firstDoc ] ++ restDocs

                    -- All items joined with breakDoc (collapses to nothing when flat)
                    itemsJoined =
                        P.foldDoc
                            (\a b -> P.concat a (P.concat P.breakDoc b))
                            allItemDocs
                in
                -- The closing ")" is always joined with nl, not breakDoc.
                -- When flat: nl collapses to a space, giving "( a, b, c )"
                -- When broken: nl gives a real newline, putting ")" on its own line
                P.concat itemsJoined (P.concat P.nl P.rparen)

{- single item on one line; multiple items each on one line
-}
bracketArray : Array String -> P.Doc cost
bracketArray items =
    when Array.popFirst items is
        Nothing ->
            -- Empty list: "()"
            P.concat P.lbrack P.rbrack

        Just { first, rest } ->
            if Array.isEmpty rest then
                -- Single element: "(foo)" — no separators, no newlines
                P.concat P.lbrack (P.concat (P.text first) P.rbrack)

            else
                -- Multiple elements.
                -- Build doc nodes: "( item1", ", item2", ..., ", itemN"
                let
                    firstDoc = P.text ("[ " ++ first)
                    restDocs = Array.map (\s -> P.text (", " ++ s)) rest
                    allItemDocs = [ firstDoc ] ++ restDocs

                    -- All items joined with breakDoc (collapses to nothing when flat)
                    itemsJoined =
                        P.foldDoc
                            (\a b -> P.concat a (P.concat P.breakDoc b))
                            allItemDocs
                in
                -- The closing ")" is always joined with nl, not breakDoc.
                -- When flat: nl collapses to a space, giving "( a, b, c )"
                -- When broken: nl gives a real newline, putting ")" on its own line
                P.concat itemsJoined (P.concat P.nl P.rbrack)



{-| Like `parenList`, but items flow across lines rather than being either
all-flat or all-broken. The printer fits as many items as possible on each
line, breaking to the next line (indented by `nestIndent`) only when the
next item would overflow.

    flowList 4 [ "Command(..)", "MakeFlags", "DiffArgs(..)", "parser" ]

Might render (at a narrow width) as:

    ( Command(..), MakeFlags
    , DiffArgs(..), parser
    )

Or (at a wide width) as:

    ( Command(..), MakeFlags, DiffArgs(..), parser )

...depending on the page width. The closing ")" is always joined with `nl`
(not `breakDoc`), so it gets a space in the widest flat case, and its own
line when anything breaks.

The caller is responsible for the leading separator and any outer nesting,
just as with `parenList`:

    P.hardNl
    |> P.concat (flowList 4 [...])

-}
flowList0 : Int -> Array String -> P.Doc cost
flowList0 nestIndent items =
    when Array.popFirst items is
        Nothing ->
            -- Empty: "()"
            P.concat P.lparen P.rparen

        Just { first, rest } ->
            if Array.isEmpty rest then
                -- Single element: "(foo)" — no breaks needed
                P.concat P.lparen (P.concat (P.text first) P.rparen)

            else
                let
                    -- Prepend "( " to the first item, ", " to the rest.
                    -- The comma-space is part of the text token so that
                    -- breakDoc (the separator) collapses to nothing in the
                    -- flat case, producing "( a, b, c" without double spaces.
                    firstDoc = P.text ("( " ++ first)
                    restDocs = Array.map (\s -> P.text (", " ++ s)) rest
                    allDocs  = [ firstDoc ] ++ restDocs

                    -- Each separator between adjacent items is wrapped in its
                    -- own independent `group`. The printer evaluates each one
                    -- at the current column: if placing the next item on this
                    -- line is cheaper (it fits), the breakDoc collapses to "".
                    -- If the line would overflow, the breakDoc becomes a real
                    -- newline and `nest nestIndent` supplies the indentation.
                    --
                    -- Because each group is independent, some gaps can be flat
                    -- while others break — producing the flowing fill layout.
                    body =
                        P.foldDoc
                            (\a b -> P.concat a (P.group (P.concat P.breakDoc b)))
                            allDocs
                in
                -- The closing ")" is separated by `nl` (not `breakDoc`):
                --   flat case:   nl → " ", giving "...last-item )"
                --   broken case: nl → newline + indent, giving ")" on its own line
                -- `nest nestIndent` sets the indentation level for every break
                -- that fires inside this document.
                P.nest nestIndent
                    (P.concat body (P.concat P.nl P.rparen))

{-
Like flowList0, but...

Now `")"`  is baked into the final text token before folding, so the
last gap before it is still an independent `group (concat breakDoc ...)`.
The `)` just comes along for the ride. The outputs become:

-- wide:
( Command(..), MakeFlags, DiffArgs(..), parser )

-- narrow, flowing:
( Command(..), MakeFlags
, DiffArgs(..), parser )

-- very narrow:
( Command(..)
, MakeFlags
, DiffArgs(..)
, parser )
-}

flowList : Int -> Array String -> P.Doc cost
flowList nestIndent items =
    when Array.popFirst items is
        Nothing ->
            P.concat P.lparen P.rparen

        Just { first, rest } ->
            if Array.isEmpty rest then
                P.concat P.lparen (P.concat (P.text first) P.rparen)

            else
                let
                    firstDoc = P.text ("( " ++ first)
                    restDocs = Array.map (\s -> P.text (", " ++ s)) rest
                    allDocs  = [ firstDoc ] ++ restDocs

                    -- Append ")" directly onto the last item so it always
                    -- travels with it — no separator, no chance to break.
                    allDocsWithParen =
                        when Array.popLast allDocs is
                            Nothing ->
                                allDocs
                            Just { initial, last } ->
                                initial ++ [ P.concat last (P.text " )") ]

                    body =
                        P.foldDoc
                            (\a b -> P.concat a (P.group (P.concat P.breakDoc b)))
                            allDocsWithParen
                in
                P.nest nestIndent body


{-
Not useful yet, but, just in case, align 2 columns of pure text
-}
{-| Render an array of (left, right) string pairs as a two-column table,
with the right column vertically aligned across all rows.

Rows where the right string is empty render as just the left text.

    alignedColumns
        [ { left = "import CodeView",         right = "" }
        , { left = "import DocConstructors",   right = "exposing (parenList, flowList)" }
        , { left = "import Msg",               right = "exposing (Msg(..))" }
        ]

The printer finds the optimal separator column (wide enough that no left cell
overflows it) and aligns all right cells there.
-}
alignedStringColumns :
    Array { left : String, right : String }
    -> P.Doc cost
alignedStringColumns rows =
    P.twoColumns
        (Array.map
            (\{ left, right } ->
                { a = P.text left
                , b = P.text right
                }
            )
            rows
        )

{- create a function declaration

functionDecl
    "flowList"
    [ "Int", "Array String", "P.Doc cost" ]
    [ "nestIndent", "items" ]
    (P.text "...")

functionDecl
    "view"
    [ "Model", "Html Msg" ]
    [ "model" ]
    (P.text "div")

-- types must not be empty!

-}
functionDecl :
    String
    -> Array String
    -> Array String
    -> P.Doc cost
    -> P.Doc cost
functionDecl name types params body =
    let
        -- "name : Type1 -> Type2 -> ReturnType"
        typeSig =
            P.text (name ++ " : " ++ String.join " -> " types)

        -- "name param1 param2 ="
        paramStr =
            if Array.isEmpty params then
                ""
            else
                " " ++ String.join " " params

        defLine =
            P.text (name ++ paramStr ++ " =")

        -- body indented 4 spaces, preceded by a mandatory newline
        indentedBody =
            P.nest 4 (P.concat P.hardNl body)
    in
    P.vcat [ typeSig, P.concat defLine indentedBody ]


{-
The four possible renderings, from widest to narrowest:

-- Everything fits:
flowList : Int -> Array String -> P.Doc cost
flowList nestIndent items =
    body

-- Types overflow, params fit:
flowList : Int
    -> Array String
    -> P.Doc cost
flowList nestIndent items =
    body

-- Both overflow:
flowList : Int
    -> Array String
    -> P.Doc cost
flowList
    nestIndent
    items =
    body
-}

functionDecl2 :
    String
    -> Array String
    -> Array String
    -> P.Doc cost
    -> P.Doc cost
functionDecl2 name types params body =
    let
        -- "name : T1 -> T2 -> T3"
        -- Flow: as many types as fit per line, continuation lines indented 4.
        -- Broken example:
        --   flowList : Int
        --       -> Array String
        --       -> P.Doc cost
        typeSig =
            when Array.popFirst types is
                Nothing ->
                    P.empty
                Just { first, rest } ->
                    let
                        firstDoc = P.text (name ++ " : " ++ first)
                        restDocs = Array.map (\t -> P.text ("-> " ++ t)) rest
                        allDocs  = [ firstDoc ] ++ restDocs
                    in
                    P.nest 4
                        (P.foldDoc
                            (\a b -> P.concat a (P.group (P.concat P.nl b)))
                            allDocs
                        )

        -- "name param1 param2 ="
        -- Flow: as many params as fit per line, continuation lines indented 4.
        -- Broken example:
        --   functionDecl name
        --       types params =
        defLine =
            when Array.popLast params is
                Nothing ->
                    -- No params: "name ="
                    P.text (name ++ " =")
                Just { initial, last } ->
                    let
                        -- "last =" is baked into the final token so "=" always
                        -- stays with the last param, never stranded on its own line.
                        firstDoc   = P.text name
                        initialDocs = Array.map P.text initial
                        lastDoc    = P.text (last ++ " =")
                        allDocs    = [ firstDoc ] ++ initialDocs ++ [ lastDoc ]
                    in
                    P.nest 4
                        (P.foldDoc
                            (\a b -> P.concat a (P.group (P.concat P.nl b)))
                            allDocs
                        )

        indentedBody =
            P.nest 4 (P.concat P.hardNl body)
    in
    P.vcat [ typeSig, P.concat defLine indentedBody ]



{- all or nothing, for types -}
functionDecl3 :
    String
    -> Array String
    -> Array String
    -> P.Doc cost
    -> P.Doc cost
functionDecl3 name types params body =
    let
        -- "name : T1 -> T2 -> T3"
        -- All-or-nothing: either all on one line, or each type on its own line.
        -- Broken example:
        --   flowList : Int
        --       -> Array String
        --       -> P.Doc cost
        typeSig =
            when Array.popFirst types is
                Nothing ->
                    P.empty
                Just { first, rest } ->
                    let
                        firstDoc = P.text (name ++ " : " ++ first)
                        restDocs = Array.map (\t -> P.text ("-> " ++ t)) rest
                        allDocs  = [ firstDoc ] ++ restDocs
                    in
                    P.nest 4
                        (P.group
                            (P.foldDoc
                                (\a b -> P.concat a (P.concat P.nl b))
                                allDocs
                            )
                        )

        -- "name param1 param2 ="
        -- Flow: as many params as fit per line, continuation lines indented 4.
        -- Broken example:
        --   functionDecl name
        --       types params =
        defLine =
            when Array.popLast params is
                Nothing ->
                    P.text (name ++ " =")
                Just { initial, last } ->
                    let
                        -- "last =" is baked into the final token so "=" always
                        -- stays with the last param, never stranded on its own line.
                        firstDoc    = P.text name
                        initialDocs = Array.map P.text initial
                        lastDoc     = P.text (last ++ " =")
                        allDocs     = [ firstDoc ] ++ initialDocs ++ [ lastDoc ]
                    in
                    P.nest 4
                        (P.foldDoc
                            (\a b -> P.concat a (P.group (P.concat P.nl b)))
                            allDocs
                        )

        indentedBody =
            P.nest 4 (P.concat P.hardNl body)
    in
    P.vcat [ typeSig, P.concat defLine indentedBody ]

{- all or nothing, both types and variables -}
functionDecl4 :
    String
    -> Array String
    -> Array String
    -> P.Doc cost
    -> P.Doc cost
functionDecl4 name types params body =
    let
        typeSig =
            when Array.popFirst types is
                Nothing ->
                    P.empty
                Just { first, rest } ->
                    let
                        firstDoc = P.text (name ++ " : " ++ first)
                        restDocs = Array.map (\t -> P.text ("-> " ++ t)) rest
                        allDocs  = [ firstDoc ] ++ restDocs
                    in
                    P.nest 4
                        (P.group
                            (P.foldDoc
                                (\a b -> P.concat a (P.concat P.nl b))
                                allDocs
                            )
                        )

        defLine =
            when Array.popLast params is
                Nothing ->
                    P.text (name ++ " =")
                Just { initial, last } ->
                    let
                        firstDoc    = P.text name
                        initialDocs = Array.map P.text initial
                        lastDoc     = P.text (last ++ " =")
                        allDocs     = [ firstDoc ] ++ initialDocs ++ [ lastDoc ]
                    in
                    P.nest 4
                        (P.group
                            (P.foldDoc
                                (\a b -> P.concat a (P.concat P.nl b))
                                allDocs
                            )
                        )

        indentedBody =
            P.nest 4 (P.concat P.hardNl body)
    in
    P.vcat [ typeSig, P.concat defLine indentedBody ]


{-
group won't work here because the two layouts have genuinely different
structure — not just collapsed vs expanded newlines. So this needs
an explicit choice with both forms written out. flatten is applied to
all three sub-docs in the flat branch so that any newlines inside them
are suppressed:

The flatten calls in flatForm do two jobs at once: they produce the
correctly-spaced single-line rendering, and they act as a guard —
if any sub-doc contains a hardNl, flatten turns it into failDoc, which
propagates through concat_array and eliminates the entire flat branch
from the choice. The broken form is then the only option, which is
exactly right: a predicate or branch that insists on newlines should
never be forced onto one line.
-}

ifThenElse : Int -> P.Doc cost -> P.Doc cost -> P.Doc cost -> P.Doc cost
ifThenElse indent predicate ifTrue ifFalse =
    P.choice
        (P.concat_array
            [ P.text "if "
            , P.flatten predicate
            , P.text " then "
            , P.flatten ifTrue
            , P.text " else "
            , P.flatten ifFalse
            ])
        (ifThenElseMultiline indent predicate ifTrue ifFalse)

{-
This is just the brokenForm from ifThenElse extracted into its own
function. If you find yourself repeating the two together often, you
could also refactor ifThenElse to call this:
-}

ifThenElseMultiline : Int -> P.Doc cost -> P.Doc cost -> P.Doc cost -> P.Doc cost
ifThenElseMultiline indent predicate ifTrue ifFalse =
    P.concat_array
        [ P.text "if "
        , predicate
        , P.text " then"
        , P.nest indent (P.concat P.hardNl ifTrue)
        , P.hardNl
        , P.text "else"
        , P.nest indent (P.concat P.hardNl ifFalse)
        ]

{-
nest indent wraps each body so that any newlines inside ifTrue or
ifFalse indent to indent spaces — but the first token of each body
sits directly after "then " or "else " on the same line, since nest only
affects newlines, not the current column position.
-}
ifThenElseKeywordsOnNewLines : Int -> P.Doc cost -> P.Doc cost -> P.Doc cost -> P.Doc cost
ifThenElseKeywordsOnNewLines indent predicate ifTrue ifFalse =
    P.concat_array
        [ P.text "if "
        , predicate
        , P.hardNl
        , P.text "then "
        , P.nest indent ifTrue
        , P.hardNl
        , P.text "else "
        , P.nest indent ifFalse
        ]


{-
Join an Array of docs with whitepsace. On a line it will be a space, but if the
line overflows, the space can be a newline.
We join with nl, but in flattened form, that's a space.
-}
joinWhitespace : Array (P.Doc cost) -> P.Doc cost
joinWhitespace docs =
    P.group <| P.vcat docs


{- the array either fits completely cross, or its rendered vertically

Tracing the two forms that `group` chooses between:

**Flat** — `flatten` collapses `breakDoc` to `""` and `nl` to `" "`:
```
[ 1, 2, 3 ]
```

**Broken** — `breakDoc` and `nl` both emit a real newline at indent 0:
```
[ 1
, 2
, 3
]
-}
arrayDoc : Array (P.Doc cost) -> P.Doc cost
arrayDoc items =
    when Array.popFirst items is
        Nothing ->
            P.text "[]"

        Just { first, rest } ->
            let
                firstDoc = P.concat (P.text "[ ") first
                restDocs = Array.map (\d -> P.concat (P.text ", ") d) rest
                allDocs  = [ firstDoc ] ++ restDocs

                joined =
                    P.foldDoc
                        (\a b -> P.concat a (P.concat P.breakDoc b))
                        allDocs
            in
            P.group
                (P.concat joined (P.concat P.nl (P.text "]")))

