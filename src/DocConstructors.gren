module DocConstructors exposing (..)

import PrettyExpressive as P


{- Useful for traditionally-formatted "exposing" statements
for "module" and "import".
-}
listOnePerLine : Int -> Array String -> P.Doc cost
listOnePerLine indent items =
    when Array.popFirst items is
        Nothing ->
            P.concat P.lparen P.rparen

        Just { first, rest } ->
            let
                firstDoc = P.text ("( " ++ first)
                restDocs = Array.map (\s -> P.text (", " ++ s)) rest
                itemDocs = [ firstDoc ] ++ restDocs ++ [ P.rparen ]
            in
            P.nest indent
                (P.concat P.hardNl
                    (P.vcat itemDocs)
                )


{-
Given a list of strings, produce ( s1, s2, s3 )
that tries to fit on one line, but if it doesn't, will
render one per line.

The three outputs this produces:
```
-- flat (everything fits):
( Command(..), MakeFlags, DiffArgs(..), parser )

-- broken (doesn't fit):
( Command(..)
, MakeFlags
, DiffArgs(..)
, parser
)

-- single element:
(Command(..))

-- empty:
()

The caller needs to group this with the desired nesting level, like this:

P.group
    (P.nest 4
        (P.concat P.nl
            (parenList [ "Command(..)", "MakeFlags", "DiffArgs(..)", "parser" ])
        )
    )
-}
parenList : Array String -> P.Doc cost
parenList items =
    when Array.popFirst items is
        Nothing ->
            -- Empty list: "()"
            P.concat P.lparen P.rparen

        Just { first, rest } ->
            if Array.isEmpty rest then
                -- Single element: "(foo)" — no separators, no newlines
                P.concat P.lparen (P.concat (P.text first) P.rparen)

            else
                -- Multiple elements.
                -- Build doc nodes: "( item1", ", item2", ..., ", itemN"
                let
                    firstDoc = P.text ("( " ++ first)
                    restDocs = Array.map (\s -> P.text (", " ++ s)) rest
                    allItemDocs = [ firstDoc ] ++ restDocs

                    -- All items joined with breakDoc (collapses to nothing when flat)
                    itemsJoined =
                        P.foldDoc
                            (\a b -> P.concat a (P.concat P.breakDoc b))
                            allItemDocs
                in
                -- The closing ")" is always joined with nl, not breakDoc.
                -- When flat: nl collapses to a space, giving "( a, b, c )"
                -- When broken: nl gives a real newline, putting ")" on its own line
                P.concat itemsJoined (P.concat P.nl P.rparen)



{-| Like `parenList`, but items flow across lines rather than being either
all-flat or all-broken. The printer fits as many items as possible on each
line, breaking to the next line (indented by `nestIndent`) only when the
next item would overflow.

    flowList 4 [ "Command(..)", "MakeFlags", "DiffArgs(..)", "parser" ]

Might render (at a narrow width) as:

    ( Command(..), MakeFlags
    , DiffArgs(..), parser
    )

Or (at a wide width) as:

    ( Command(..), MakeFlags, DiffArgs(..), parser )

...depending on the page width. The closing ")" is always joined with `nl`
(not `breakDoc`), so it gets a space in the widest flat case, and its own
line when anything breaks.

The caller is responsible for the leading separator and any outer nesting,
just as with `parenList`:

    P.hardNl
    |> P.concat (flowList 4 [...])

-}
flowList0 : Int -> Array String -> P.Doc cost
flowList0 nestIndent items =
    when Array.popFirst items is
        Nothing ->
            -- Empty: "()"
            P.concat P.lparen P.rparen

        Just { first, rest } ->
            if Array.isEmpty rest then
                -- Single element: "(foo)" — no breaks needed
                P.concat P.lparen (P.concat (P.text first) P.rparen)

            else
                let
                    -- Prepend "( " to the first item, ", " to the rest.
                    -- The comma-space is part of the text token so that
                    -- breakDoc (the separator) collapses to nothing in the
                    -- flat case, producing "( a, b, c" without double spaces.
                    firstDoc = P.text ("( " ++ first)
                    restDocs = Array.map (\s -> P.text (", " ++ s)) rest
                    allDocs  = [ firstDoc ] ++ restDocs

                    -- Each separator between adjacent items is wrapped in its
                    -- own independent `group`. The printer evaluates each one
                    -- at the current column: if placing the next item on this
                    -- line is cheaper (it fits), the breakDoc collapses to "".
                    -- If the line would overflow, the breakDoc becomes a real
                    -- newline and `nest nestIndent` supplies the indentation.
                    --
                    -- Because each group is independent, some gaps can be flat
                    -- while others break — producing the flowing fill layout.
                    body =
                        P.foldDoc
                            (\a b -> P.concat a (P.group (P.concat P.breakDoc b)))
                            allDocs
                in
                -- The closing ")" is separated by `nl` (not `breakDoc`):
                --   flat case:   nl → " ", giving "...last-item )"
                --   broken case: nl → newline + indent, giving ")" on its own line
                -- `nest nestIndent` sets the indentation level for every break
                -- that fires inside this document.
                P.nest nestIndent
                    (P.concat body (P.concat P.nl P.rparen))

{-
Like flowList0, but...

Now `")"`  is baked into the final text token before folding, so the
last gap before it is still an independent `group (concat breakDoc ...)`.
The `)` just comes along for the ride. The outputs become:

-- wide:
( Command(..), MakeFlags, DiffArgs(..), parser )

-- narrow, flowing:
( Command(..), MakeFlags
, DiffArgs(..), parser )

-- very narrow:
( Command(..)
, MakeFlags
, DiffArgs(..)
, parser )
-}

flowList : Int -> Array String -> P.Doc cost
flowList nestIndent items =
    when Array.popFirst items is
        Nothing ->
            P.concat P.lparen P.rparen

        Just { first, rest } ->
            if Array.isEmpty rest then
                P.concat P.lparen (P.concat (P.text first) P.rparen)

            else
                let
                    firstDoc = P.text ("( " ++ first)
                    restDocs = Array.map (\s -> P.text (", " ++ s)) rest
                    allDocs  = [ firstDoc ] ++ restDocs

                    -- Append ")" directly onto the last item so it always
                    -- travels with it — no separator, no chance to break.
                    allDocsWithParen =
                        when Array.popLast allDocs is
                            Nothing ->
                                allDocs
                            Just { initial, last } ->
                                initial ++ [ P.concat last (P.text " )") ]

                    body =
                        P.foldDoc
                            (\a b -> P.concat a (P.group (P.concat P.breakDoc b)))
                            allDocsWithParen
                in
                P.nest nestIndent body


{-
Not useful yet, but, just in case, align 2 columns of pure text
-}
{-| Render an array of (left, right) string pairs as a two-column table,
with the right column vertically aligned across all rows.

Rows where the right string is empty render as just the left text.

    alignedColumns
        [ { left = "import CodeView",         right = "" }
        , { left = "import DocConstructors",   right = "exposing (parenList, flowList)" }
        , { left = "import Msg",               right = "exposing (Msg(..))" }
        ]

The printer finds the optimal separator column (wide enough that no left cell
overflows it) and aligns all right cells there.
-}
alignedStringColumns :
    Array { left : String, right : String }
    -> P.Doc cost
alignedStringColumns rows =
    P.twoColumns
        (Array.map
            (\{ left, right } ->
                { a = P.text left
                , b = P.text right
                }
            )
            rows
        )

{- create a function declaration

functionDecl
    "flowList"
    [ "Int", "Array String", "P.Doc cost" ]
    [ "nestIndent", "items" ]
    (P.text "...")

functionDecl
    "view"
    [ "Model", "Html Msg" ]
    [ "model" ]
    (P.text "div")

-- types must not be empty!

-}
functionDecl :
    String
    -> Array String
    -> Array String
    -> P.Doc cost
    -> P.Doc cost
functionDecl name types params body =
    let
        -- "name : Type1 -> Type2 -> ReturnType"
        typeSig =
            P.text (name ++ " : " ++ String.join " -> " types)

        -- "name param1 param2 ="
        paramStr =
            if Array.isEmpty params then
                ""
            else
                " " ++ String.join " " params

        defLine =
            P.text (name ++ paramStr ++ " =")

        -- body indented 4 spaces, preceded by a mandatory newline
        indentedBody =
            P.nest 4 (P.concat P.hardNl body)
    in
    P.vcat [ typeSig, P.concat defLine indentedBody ]
