module Views.ModuleLinePage exposing (view)

import Html exposing (Html, h1, h2, div, p, text, pre)

import PrettyExpressive as P
import PrettyExpressive.Debug exposing (debugShowDoc)

import CodeView
import DocConstructors exposing (parenList, flowList)
import Msg exposing (Msg(..))
import Model exposing (..)
import PrettyConfig exposing (cf60, cf80, guidelines, guidelines60)

view : Model -> Html Msg
view model =
    div [] [
        h1 [] [ text "The Module Line" ],

        p [] [
            text """
Let's look at different options of displaying the first
line of a file, the "module" line. There are different ways to render
it when the list of "exposing" symbols is long.
"""
        ],

        h2 [] [ text "The Traditional Way" ],
        section_onePerLine model,

        h2 [] [ text "Try to fit on one line, but revert to Traditional" ],
        section_allOrNothing model,

        h2 [] [ text "Flow across many lines" ],
        section_flowing model
    ]



onePerLine : P.Doc cost
onePerLine =
    let
        exposingList : P.Doc cost
        exposingList =
            P.nest 4
                (P.concat P.hardNl
                    (P.vcat
                        [ P.text "( Command(..)"
                        , P.text ", MakeFlags"
                        , P.text ", DiffArgs(..)"
                        , P.text ", parser"
                        , P.text ")"
                        ]
                    )
                )
    in
        P.concat
            (P.text "module Terminal.Parser exposing")
            exposingList

section_onePerLine : Model -> Html Msg
section_onePerLine model =
    let
        rendered = when P.prettyFormat cf80 onePerLine is
            Nothing -> "Failed to render"
            Just prettyPrinted -> prettyPrinted
    in
        div [] [
            p [] [
                text """
Let's look at a module that exposes many symbols. The format that is generally
used is to show one symbol per line, with one indentation.
"""
            ],
            CodeView.view rendered guidelines "One Exposed Symbol Per Line",

            p [] [
                text """
This is generated from this Doc.
"""
            ],
            pre [] [
                text (debugShowDoc onePerLine)
            ]

        ]


-- Either all the exposingItems fit on one line, or they each
-- are on their own line
allOrNothing0 : P.Doc cost
allOrNothing0 =
    let
        -- Join items with breakable zero-width separators.
        -- Flat:   "( Command (..), MakeFlags, DiffArgs (..), parser )"
        -- Broken: each item on its own line (breakDoc â†’ real newline at indent=4)
        joinItems : Array (P.Doc cost) -> P.Doc cost
        joinItems =
            P.foldDoc (\a b -> P.concat a (P.concat P.breakDoc b))

        exposingItems : P.Doc cost
        exposingItems =
            joinItems
                [ P.text "( Command(..)"
                , P.text ", MakeFlags"
                , P.text ", DiffArgs(..)"
                , P.text ", parser"
                , P.text ")"
                ]

        -- group tries flat first; falls back to broken if it overflows.
        -- nest 4 means all broken newlines (both the leading nl and the
        -- breakDoc separators between items) land at column 4.
        exposingList : P.Doc cost
        exposingList =
            P.group
                (P.nest 4
                    (P.concat P.nl exposingItems)
                )

    in
        P.concat
            (P.text "module Terminal.Parser exposing")
            exposingList

allOrNothing: P.Doc cost
allOrNothing =
    let
        exposingItems : P.Doc cost
        exposingItems =
            parenList [ "Command(..)", "MakeFlags", "DiffArgs(..)", "parser" ]

        -- group tries flat first; falls back to broken if it overflows.
        -- nest 4 means all broken newlines (both the leading nl and the
        -- breakDoc separators between items) land at column 4.
        exposingList : P.Doc cost
        exposingList =
            P.group
                (P.nest 4
                    (P.concat P.nl exposingItems)
                )
    in
        P.concat
            (P.text "module Terminal.Parser exposing")
            exposingList

section_allOrNothing : Model -> Html Msg
section_allOrNothing model =
    let
        rendered80 = when P.prettyFormat cf80 allOrNothing is
            Nothing -> "Failed to render"
            Just prettyPrinted -> prettyPrinted

        rendered60 = when P.prettyFormat cf60 allOrNothing is
            Nothing -> "Failed to render"
            Just prettyPrinted -> prettyPrinted
    in
        div [] [
            p [] [
                text """
Another option is to try to fit all the exposed symbols on the same line.
If they fit, great. If not, they are printed on multiple lines.
"""
            ],

            p [] [
                text """
At 80-columns, it renders as:
"""
            ],

            CodeView.view rendered80 guidelines "All on the same line",

            p [] [
                text """
Whereas if we rendered that same Doc at 60 columns (or if the list of symbols
become too long to fit in 80 columns), it would automatically
be rendered in a multiline format because the single-line version is too long.
"""
            ],
            CodeView.view rendered60 guidelines60 "Split into multiple lines",

            p [] [
                text """
This is the Doc that produces these two behaviors.
"""
            ],
            pre [] [ text (debugShowDoc allOrNothing) ]

        ]



flowing: P.Doc cost
flowing =
    let
        exposingItems : P.Doc cost
        exposingItems =
            flowList 4 [ "CostFactory", "DefaultCostTuple", "Doc(..)", "DocPair",
                        "Info", "addCost", "align", "alignedConcat", "breakDoc", "choice",
                        "comma", "concat", "concat_array", "defaultCostFactory", "dquote",
                        "empty", "failDoc", "flatten", "flattenAlignedConcat", "foldDoc"
                        ]

        exposingList : P.Doc cost
        exposingList =
            P.hardNl
                |> P.concat exposingItems
    in
        P.concat
            -- We have to put the space after "exposing"
            (P.text "module Terminal.Parser exposing ")
            exposingList

section_flowing : Model -> Html Msg
section_flowing model =
    let
        rendered80 = when P.prettyFormat cf80 flowing is
            Nothing -> "Failed to render"
            Just prettyPrinted -> prettyPrinted
    in
        div [] [
            p [] [
                text """
Another option is to try to fit as many symbols on each line
as possible. As additional lines are used, the entire line is used too,
instead of having one symbol per line.
"""
            ],

            CodeView.view rendered80 guidelines "Flowing across multiple lines",

            p [] [
                text """
This is the Doc that produces this rendering.
"""
            ],
            pre [] [ text (debugShowDoc flowing) ]
        ]

