module Views.ImportsPage exposing (view)

import Html exposing (Html, h1, h2, div, p, text, pre)

import PrettyExpressive as P
import PrettyExpressive.Debug exposing (debugShowDoc)

import CodeView
import DocConstructors exposing (..)
import Msg exposing (Msg(..))
import Model exposing (Model)
import PrettyConfig exposing (..)


view : Model -> Html Msg
view model =
    div [] [
        h1 [] [ text "Imports" ],

        p [] [
            text """
"import" statements are very similar to "module" statements.
However, when the program has many "import" statements in sequence,
there is an opportunity to align the "exposing" part in a column.
"""
        ],

        h2 [] [ text "Non-aligned, One-Per-Line" ],
        section_nonAlignedOnePer model,

        h2 [] [ text "Non-aligned, Flowing Across" ],
        section_nonAlignedFlowing model,

        h2 [] [ text "Aligned, Flowing Across" ],
        section_alignedFlowing model,

        h2 [] [ text "Symbols Aligned, Flowing Across" ],
        section_alignedFlowing2 model,

        h2 [] [ text "Symbols Aligned, Columnar-Flowing" ],
        section_alignedColumnar model
    ]

tradImportOnePer : String -> Array String -> P.Doc cost
tradImportOnePer pkg symbols =
    let
        exposingItems = parenList symbols

        exposingList =
            P.group
                (P.nest 4
                    (P.concat P.nl exposingItems)
                )
    in
        if Array.length symbols == 0 then
                P.text ("import " ++ pkg)
        else
            P.concat
                (P.text ("import " ++ pkg ++ " exposing"))
                exposingList


nonAlignedOnePer : P.Doc cost
nonAlignedOnePer =
    P.vcat [
        tradImportOnePer "CodeView" [],
        tradImportOnePer "DocConstructors" [ "parenList", "flowList" ],
        tradImportOnePer "Short" [ "oneSymbol" ],
        tradImportOnePer "PrettyConfig" [ "cf60", "cf80", "guidelines",
        "guidelines60", "anotherLongSymbol" ]
    ]

section_nonAlignedOnePer : Model -> Html Msg
section_nonAlignedOnePer model =
    let
        rendered = when P.prettyFormat cf80 nonAlignedOnePer is
            Nothing -> "Failed to render"
            Just prettyPrinted -> prettyPrinted
    in
        div [] [
            p [] [
                text """
Here is a non-aligned set of "import" statements, for reference.
The first import has no list of symbols.
The second and thirs lines have short lists,
and the last one has a long list that can't fit on a single line.
"""
            ],
            CodeView.view rendered guidelines80 "Import statement block, not aligned, one-per-line"

        ]


tradImportFlowing : String -> Array String -> P.Doc cost
tradImportFlowing pkg symbols =
    let
        exposingItems = flowList 4 symbols
        exposingList = exposingItems
        {-
            P.hardNl
                |> P.concat exposingItems
                -}
    in
        if Array.length symbols == 0 then
                P.text ("import " ++ pkg)
        else
            P.concat
                (P.text ("import " ++ pkg ++ " exposing "))
                exposingList

nonAlignedFlowing : P.Doc cost
nonAlignedFlowing =
    P.vcat [
        tradImportFlowing "CodeView" [],
        tradImportFlowing "DocConstructors" [ "parenList", "flowList" ],
        tradImportFlowing  "Short" [ "oneSymbol" ],
        tradImportFlowing "PrettyConfig" [ "cf60", "cf80", "guidelines",
        "guidelines60", "anotherLongSymbol" ]
    ]

section_nonAlignedFlowing : Model -> Html Msg
section_nonAlignedFlowing model =
    let
        rendered = when P.prettyFormat cf80 nonAlignedFlowing is
            Nothing -> "Failed to render"
            Just prettyPrinted -> prettyPrinted
    in
        div [] [
            p [] [
                text """
Here is the same block, but allowing symbols after the first line to flow
across the line.
"""
            ],
            CodeView.view rendered guidelines80 "Import statement block, not aligned, flowing across"

        ]


exposingColumnFlowing : Array String -> P.Doc cost
exposingColumnFlowing symbols =
    P.concat
        (P.text " exposing ")
        (flowList 4 symbols)

alignedFlowing : P.Doc cost
alignedFlowing =
    P.twoColumns
    [ { a = P.text "import CodeView",        b = P.empty }
    , { a = P.text "import DocConstructors", b = exposingColumnFlowing [ "parenList", "flowList" ] }
    , { a = P.text "import Short",           b = exposingColumnFlowing [ "oneSymbol" ] }
    , { a = P.text "import PrettyConfig",    b = exposingColumnFlowing [
        "cf60", "cf80", "guidelines", "guidelines60", "anotherLongSymbol" ] }
    ]

section_alignedFlowing : Model -> Html Msg
section_alignedFlowing model =
    let
        rendered = when P.prettyFormat cf80 alignedFlowing is
            Nothing -> "Failed to render"
            Just prettyPrinted -> prettyPrinted
    in
        div [] [
            p [] [
                text """
Here is the same block, but aligning the "exposing" part into columns, and
having those symbols flow across the line. It uses PrettyExpressive's TwoColumn Doc type
so the pretty-printer can choose the correct column for "exposing" by itself.
"""

            ],
            CodeView.view rendered guidelines80 "Import statement block, aligned, flowing across"

        ]

symbolColumnFlowing : Array String -> P.Doc cost
symbolColumnFlowing symbols =
    (flowList 4 symbols)

alignedFlowing2 : P.Doc cost
alignedFlowing2 =
    P.twoColumns
    [ { a = P.text "import CodeView", b = P.empty }
    , { a = P.text "import DocConstructors exposing ", b = symbolColumnFlowing [ "parenList", "flowList" ] }
    , { a = P.text "import Short exposing ",           b = symbolColumnFlowing [ "oneSymbol" ] }
    , { a = P.text "import PrettyConfig exposing ",    b = symbolColumnFlowing [
        "cf60", "cf80", "guidelines", "guidelines60", "anotherLongSymbol" ] }
    ]

section_alignedFlowing2 : Model -> Html Msg
section_alignedFlowing2 model =
    let
        rendered = when P.prettyFormat cf80 alignedFlowing2 is
            Nothing -> "Failed to render"
            Just prettyPrinted -> prettyPrinted
    in
        div [] [
            p [] [
                text """
Or, maybe the "exposing" should be with the "import" and package name, and the
list of symbols should start the new column.
"""

            ],
            CodeView.view rendered guidelines80 "Import statement block, symbols aligned, flowing across"
        ]

symbolColumnar : Array String -> P.Doc cost
symbolColumnar symbols =
    P.align (flowList 0 symbols)

alignedColumnar : P.Doc cost
alignedColumnar =
    P.twoColumns
    [ { a = P.text "import CodeView", b = P.empty }
    , { a = P.text "import DocConstructors exposing ", b = symbolColumnar [ "parenList", "flowList" ] }
    , { a = P.text "import Short exposing ",           b = symbolColumnar [ "oneSymbol" ] }
    , { a = P.text "import PrettyConfig exposing ",    b = symbolColumnar [
        "cf60", "cf80", "guidelines", "guidelines60", "anotherLongSymbol" ] }
    ]

section_alignedColumnar : Model -> Html Msg
section_alignedColumnar model =
    let
        rendered = when P.prettyFormat cf80 alignedColumnar is
            Nothing -> "Failed to render"
            Just prettyPrinted -> prettyPrinted
    in
        div [] [
            p [] [
                text """
Additionally, when wrapping the list of symbols to the next line, we could
flow them across the column instead of the entire line.
"""

            ],
            CodeView.view rendered guidelines80 "Import statement block, symbols aligned, columnar-flowing"
        ]
